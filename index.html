<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8" />
  <title>Advanced Image & Text Editor</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 0;
      background-color: white;
      height: 100vh;
      overflow: hidden;
    }
    #main-container {
      display: flex;
      height: 100vh;
      width: 100%;
      overflow: hidden;
    }
    #editor-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: auto;
      height: 100vh;
    }
    #editor {
      background: #ffffff;
      padding: 20px;
      width: 212mm;
      margin: 20px auto;
      box-sizing: border-box;
      font-family: 'Verdana', sans-serif;
      font-size: 16px;
      color: #000;
      position: relative;
    }
    #sidebar {
      width: 250px;
      padding: 20px;
      background: #f1f1f1;
      box-sizing: border-box;
      height: 100vh;
      overflow-y: auto;
    }
    .draggable,
    .text-block,
    .img-element,
    .img-container {
      position: absolute;
      cursor: move;
      user-select: none;
      padding: 8px 12px;
      font-size: 14px;
      font-family: 'Verdana', sans-serif;
      border-radius: 8px;
      box-sizing: border-box;
    }
    .draggable {
      background: #ff0000;
      color: #000000;
      min-width: 30px;
      min-height: 30px;
    }
    .text-block {
      background: white;
      color: #000;
      min-width: 80px;
      min-height: 40px;
      text-align: justify;
    }
    .img-element {
      border: 1px dashed #888;
      background: transparent;
      max-width: 800px;
      max-height: 800px;
      resize: none;
    }
    .img-container:hover .img-element {
      outline: 2px dashed #007BFF;
    }
    .img-container {
      border: none;
      background: transparent;
    }
    .task-btn {
      background-color: #28a745;
      color: white;
      border-radius: 8px;
      padding: 8px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 10px;
      width: 100%;
      border: none;
    }
    .task-btn:hover {
      background-color: #218838;
    }
    .task-management {
      margin-top: 20px;
      border-top: 1px solid #ccc;
      padding-top: 20px;
    }
    .task-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      padding: 5px;
      background: white;
    }
    .task-item {
      padding: 5px;
      margin: 3px 0;
      background: #eee;
      border-radius: 4px;
      cursor: pointer;
    }
    .task-item:hover {
      background: #ddd;
    }
    .task-item.active {
      background: #007BFF;
      color: white;
    }
    input {
      width: calc(100% - 20px);
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .task-page {
      position: relative;
      width: 210mm;
      min-height: 297mm;
      margin-bottom: 20px;
      background: white;
      border: 1px solid #ccc;
      box-sizing: border-box;
      page-break-after: always;
    }
    .page-indicator {
      position: absolute;
      bottom: 0;
      right: 0;
      padding: 5px;
      background: rgba(0, 0, 0, 0.1);
      font-size: 12px;
    }
    .task-pages-container {
      display: none;
    }
    .task-pages-container.active {
      display: block;
    }
    .page-controls {
      margin-top: 10px;
      display: flex;
      gap: 5px;
    }
    .page-btn {
      padding: 5px 10px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .page-btn:hover {
      background: #5a6268;
    }
    .selected {
      outline: 2px solid #007BFF;
    }
    /* JSON viewer styles */
    #json-viewer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10000;
      display: none;
      overflow: auto;
      padding: 20px;
      box-sizing: border-box;
    }
    #json-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      max-width: 800px;
      margin: 20px auto;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 80vh;
      overflow: auto;
    }
    #close-json,
    #copy-json {
      position: absolute;
      top: 20px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 15px;
      cursor: pointer;
    }
    #copy-json {
      right: 120px;
    }
    #close-json {
      right: 20px;
    }
  </style>
</head>
<body>
  <div id="main-container">
    <div id="sidebar">
      <h2>Task Controls</h2>
      <button class="task-btn" onclick="addNumber()">Add Number</button>
      <input type="number" id="customNumber" placeholder="Custom Number" min="1" max="999" />
      <button class="task-btn" onclick="addTextField()">Add Text Field</button>
      <input type="text" id="customText" placeholder="Custom Text" />

      <div class="task-management">
	
        <h3>Task Management</h3>
        <div class="task-list" id="taskList"></div>
        <button class="task-btn" onclick="addNewTask()">Add New Task</button>
      
        
        
       
		<BR>
        <input type="file" id="fileInput" accept=".json" onchange="importData(this)" style="display: none;" />
		<BR><BR><BR>
        <input type="password" id="taskPassword" placeholder="Password: 123" />
		<button class="task-btn" onclick="removeCurrentTask()">Remove Task <br>(add password: 123)</button>
      </div>

      <div class="page-management" id="pageManagement" style="display: none;">
        <h3>Page Management</h3>
        <div class="page-controls">
          <button class="page-btn" onclick="addNewPage()">Add Page</button>
          <button class="page-btn" onclick="removeCurrentPage()">Remove Page</button>
        </div>
        <div class="page-list" id="pageList"></div>
      </div>
	  
	    <h3>Restore Management</h3>
	   <button class="task-btn" onclick="document.getElementById('fileInput').click()">Restore Backup</button>
 <h3>Download Management</h3>
      <button class="task-btn" onclick="downloadPDF()">Download as PDF</button>
	  <button class="task-btn" onclick="exportData()">Download Backup</button>
      <button class="task-btn" onclick="showCurrentJSON()">Show Current JSON</button>

    </div>

    <div id="editor-container">
      <div id="editor"></div>
    </div>
  </div>

  <!-- JSON Viewer Modal -->
  <div id="json-viewer">
    <button id="close-json" onclick="closeJSONViewer()">Close</button>
    <button id="copy-json" onclick="copyJSONToClipboard()">Copy JSON</button>
    <div id="json-content"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js "></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js "></script>
  <script>
    // Set PDF.js worker path
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js ';

    let numberCounter = 1;
    let tasks = [];
    let activeTaskIndex = 0;
    let activePageIndex = 0;
    let selectedElement = null;
    let isEditMode = false;

    window.onload = function () {
      const savedData = localStorage.getItem('taskEditorData');
      if (savedData && !isDataTooBig(savedData)) {
        loadFromLocalStorage();
      } else {
        addNewTask();
      }

      document.addEventListener('keydown', function (e) {
        if (e.key === 'Delete' && selectedElement) deleteSelectedElement();
        if (e.key === 'c' && !isEditMode) {
          e.preventDefault();
          addNumber();
        }
        if (e.key === 't' && !isEditMode) {
          e.preventDefault();
          addTextField();
        }
      });

      document.addEventListener('click', function (e) {
        if (
          e.target.classList.contains('draggable') ||
          e.target.classList.contains('text-block') ||
          e.target.classList.contains('img-container') ||
          e.target.classList.contains('img-element')
        ) {
          let element = e.target.classList.contains('img-element')
            ? e.target.parentElement
            : e.target;
          selectElement(element);
        } else if (!e.target.closest('.draggable, .text-block, .img-container')) {
          deselectAll();
        }
      });

      document.addEventListener('focusin', function (e) {
        if (e.target.classList.contains('draggable') || e.target.classList.contains('text-block')) {
          isEditMode = true;
        }
      });

      document.addEventListener('focusout', function (e) {
        if (e.target.classList.contains('draggable') || e.target.classList.contains('text-block')) {
          isEditMode = false;
          saveToLocalStorage();
        }
      });
    };

    function selectElement(element) {
      deselectAll();
      selectedElement = element;
      element.classList.add('selected');
    }

    function deselectAll() {
      if (selectedElement) selectedElement.classList.remove('selected');
      selectedElement = null;
    }

    function deleteSelectedElement() {
      if (selectedElement) {
        selectedElement.remove();
        selectedElement = null;
        saveToLocalStorage();
      }
    }

    function saveToLocalStorage() {
      const tasksData = tasks.map(task =>
        task.map(page => {
          const elements = Array.from(page.querySelectorAll('.draggable, .text-block, .img-container'));
          return elements.map(el => {
            const data = {
              type: el.classList.contains('draggable')
                ? 'number'
                : el.classList.contains('text-block')
                ? 'text'
                : 'image',
              content: el.classList.contains('img-container') ? el.querySelector('img').src : el.innerText,
              style: {
                top: el.style.top || '100px',
                left: el.style.left || '100px',
                fontSize: el.style.fontSize || '',
                color: el.style.color || '',
                backgroundColor: el.style.backgroundColor || '',
                textAlign: el.style.textAlign || 'justify'
              }
            };
            if (data.type === 'image') {
              const img = el.querySelector('img');
              data.style.width = img.style.width || '';
              data.style.height = img.style.height || '';
            }
            return data;
          });
        })
      );

      const fullData = {
        version: '1.2',
        timestamp: new Date().toISOString(),
        tasks: tasksData,
        activeTaskIndex: activeTaskIndex,
        activePageIndex: activePageIndex,
        numberCounter: numberCounter
      };

      if (!isDataTooBig(fullData)) {
        localStorage.setItem('taskEditorData', JSON.stringify(fullData));
      }
    }

    function isDataTooBig(data) {
      const str = JSON.stringify(data);
      const sizeInMB = (str.length * 2) / (1024 * 1024); // bytes to MB
      return sizeInMB > 2; // np. ograniczenie do 2MB
    }

    function loadFromLocalStorage() {
      const savedData = localStorage.getItem('taskEditorData');
      if (!savedData) return;
      try {
        const data = JSON.parse(savedData);
        loadFromJSON(data);
      } catch (e) {
        alert('Niepoprawny format danych w localStorage!');
      }
    }

    function loadFromJSON(data) {
      tasks = [];
      const editor = document.getElementById('editor');
      editor.innerHTML = '';

      data.tasks.forEach((taskData, taskIndex) => {
        const newTask = [];
        taskData.forEach((pageData, pageIndex) => {
          const newPage = createNewPage(taskIndex, pageIndex);
          newTask.push(newPage);

          pageData.forEach(elementData => {
            let element;
            if (elementData.type === 'number') {
              element = document.createElement('div');
              element.className = 'draggable';
              element.contentEditable = true;
              element.innerText = elementData.content;
            } else if (elementData.type === 'text') {
              element = document.createElement('div');
              element.className = 'text-block';
              element.contentEditable = true;
              element.innerText = elementData.content;
              element.style.textAlign = elementData.style.textAlign || 'justify';
            } else if (elementData.type === 'image') {
              const container = document.createElement('div');
              container.className = 'img-container';
              const img = document.createElement('img');
              img.src = elementData.content;
              img.className = 'img-element';
              if (elementData.style.width) img.style.width = elementData.style.width;
              if (elementData.style.height) img.style.height = elementData.style.height;
              container.appendChild(img);
              element = container;
            }

            if (elementData.style) {
              element.style.top = elementData.style.top || '100px';
              element.style.left = elementData.style.left || '100px';
              element.style.fontSize = elementData.style.fontSize || '';
              element.style.color = elementData.style.color || '';
              element.style.backgroundColor = elementData.style.backgroundColor || '';
            }

            makeDraggable(element);
            newPage.appendChild(element);
          });
        });
        tasks.push(newTask);
      });

      numberCounter = data.numberCounter || 1;
      activeTaskIndex = data.activeTaskIndex || 0;
      activePageIndex = data.activePageIndex || 0;
      switchTask(activeTaskIndex);
      updatePageManagement();
    }

    function createNewPage(taskIndex, pageIndex) {
      const newPage = document.createElement('div');
      newPage.className = 'task-page';
      const indicator = document.createElement('div');
      indicator.className = 'page-indicator';
      indicator.textContent = `Task ${taskIndex + 1} - Page ${pageIndex + 1}`;
      newPage.appendChild(indicator);

      const container = document.createElement('div');
      container.className = 'task-pages-container';
      if (taskIndex === activeTaskIndex && pageIndex === activePageIndex) container.classList.add('active');

      container.appendChild(newPage);
      document.getElementById('editor').appendChild(container);
      return newPage;
    }

    function addNumber() {
      if (!tasks[activeTaskIndex] || !tasks[activeTaskIndex][activePageIndex]) return;
      const div = document.createElement('div');
      div.className = 'draggable';
      div.contentEditable = true;
      div.innerText = document.getElementById('customNumber').value || numberCounter++;
      div.style.top = '100px';
      div.style.left = '100px';
      makeDraggable(div);
      tasks[activeTaskIndex][activePageIndex].appendChild(div);
      saveToLocalStorage();
    }

    function addTextField() {
      if (!tasks[activeTaskIndex] || !tasks[activeTaskIndex][activePageIndex]) return;
      const div = document.createElement('div');
      div.className = 'text-block';
      div.contentEditable = true;
      div.innerText = document.getElementById('customText').value || 'Click to edit text...';
      div.style.textAlign = 'justify';
      div.style.top = '150px';
      div.style.left = '100px';
      makeDraggable(div);
      tasks[activeTaskIndex][activePageIndex].appendChild(div);
      saveToLocalStorage();
    }

    function addNewTask() {
      const newTask = [];
      const newPage = createNewPage(tasks.length, 0);
      newTask.push(newPage);
      tasks.push(newTask);
      updateTaskList();
      switchTask(tasks.length - 1);
      saveToLocalStorage();
    }

    function updateTaskList() {
      const taskList = document.getElementById('taskList');
      taskList.innerHTML = '';
      tasks.forEach((task, index) => {
        const taskItem = document.createElement('div');
        taskItem.className = 'task-item' + (index === activeTaskIndex ? ' active' : '');
        taskItem.innerText = `Task ${index + 1} (${task.length} pages)`;
        taskItem.onclick = () => switchTask(index);
        taskList.appendChild(taskItem);
      });
    }

    function switchTask(index) {
      if (index < 0 || index >= tasks.length) return;
      document.querySelectorAll('.task-pages-container').forEach(c => c.style.display = 'none');
      tasks[index].forEach((p, i) => {
        p.parentElement.style.display = i === activePageIndex ? 'block' : 'none';
      });
      activeTaskIndex = index;
      activePageIndex = 0;
      updateTaskList();
      updatePageManagement();
      saveToLocalStorage();
    }

    function removeCurrentTask() {
      const password = document.getElementById('taskPassword').value;
      if (password !== '123') {
        alert('Incorrect password. Use "123"');
        return;
      }

      if (tasks.length <= 1) {
        alert('Cannot remove the last task.');
        return;
      }

      tasks.splice(activeTaskIndex, 1);
      activeTaskIndex = Math.max(0, activeTaskIndex - 1);
      document.getElementById('editor').innerHTML = '';
      tasks.forEach((task, ti) => {
        task.forEach((page, pi) => {
          const container = document.createElement('div');
          container.className = 'task-pages-container';
          if (ti === activeTaskIndex && pi === activePageIndex) container.classList.add('active');
          container.appendChild(page);
          document.getElementById('editor').appendChild(container);
        });
      });
      switchTask(activeTaskIndex);
      saveToLocalStorage();
    }

    function showCurrentJSON() {
      const jsonViewer = document.getElementById('json-viewer');
      const jsonContent = document.getElementById('json-content');

      const currentData = {
        version: '1.2',
        timestamp: new Date().toISOString(),
        tasks: tasks.map(task =>
          task.map(page => {
            const elements = Array.from(page.querySelectorAll('.draggable, .text-block, .img-container'));
            return elements.map(el => {
              const data = {
                type: el.classList.contains('draggable')
                  ? 'number'
                  : el.classList.contains('text-block')
                  ? 'text'
                  : 'image',
                content: el.classList.contains('img-container') ? el.querySelector('img').src : el.innerText,
                style: {
                  top: el.style.top || '100px',
                  left: el.style.left || '100px',
                  fontSize: el.style.fontSize || '',
                  color: el.style.color || '',
                  backgroundColor: el.style.backgroundColor || '',
                  textAlign: el.style.textAlign || 'justify'
                }
              };
              if (data.type === 'image') {
                const img = el.querySelector('img');
                data.style.width = img.style.width || '';
                data.style.height = img.style.height || '';
              }
              return data;
            });
          })
        ),
        activeTaskIndex: activeTaskIndex,
        activePageIndex: activePageIndex,
        numberCounter: numberCounter
      };

      try {
        jsonContent.textContent = JSON.stringify(currentData, null, 2);
        jsonViewer.style.display = 'block';
      } catch (e) {
        alert('Failed to generate JSON for preview');
      }
    }

    function importData(input) {
      const file = input.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const data = JSON.parse(e.target.result);
          if (!data.tasks) throw new Error('Invalid backup file');
          if (confirm('Are you sure? This will overwrite current data.')) {
            loadFromJSON(data);
            alert('Backup restored successfully!');
          }
        } catch (error) {
          alert('Error restoring backup: ' + error.message);
          console.error(error);
        }
        input.value = '';
      };
      reader.readAsText(file);
    }

    function exportData() {
      const currentData = {
        version: '1.2',
        timestamp: new Date().toISOString(),
        tasks: tasks.map(task =>
          task.map(page => {
            const elements = Array.from(page.querySelectorAll('.draggable, .text-block, .img-container'));
            return elements.map(el => {
              const data = {
                type: el.classList.contains('draggable') ? 'number' : el.classList.contains('text-block') ? 'text' : 'image',
                content: el.classList.contains('img-container') ? el.querySelector('img').src : el.innerText,
                style: {
                  top: el.style.top || '100px',
                  left: el.style.left || '100px',
                  fontSize: el.style.fontSize || '',
                  color: el.style.color || '',
                  backgroundColor: el.style.backgroundColor || '',
                  textAlign: el.style.textAlign || 'justify'
                }
              };
              if (data.type === 'image') {
                const img = el.querySelector('img');
                data.style.width = img.style.width || '';
                data.style.height = img.style.height || '';
              }
              return data;
            });
          })
        ),
        activeTaskIndex: activeTaskIndex,
        activePageIndex: activePageIndex,
        numberCounter: numberCounter
      };

      const blob = new Blob([JSON.stringify(currentData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `task-editor-backup-${new Date().toISOString().slice(0, 10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function closeJSONViewer() {
      document.getElementById('json-viewer').style.display = 'none';
    }

    function copyJSONToClipboard() {
      const json = document.getElementById('json-content').textContent;
      navigator.clipboard.writeText(json).then(() => {
        alert('JSON copied to clipboard!');
      }).catch(err => {
        alert('Failed to copy JSON');
        console.error(err);
      });
    }

    function makeDraggable(elmnt) {
      let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
      let isDragging = false;

      elmnt.onmousedown = function (e) {
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
        elmnt.style.zIndex = 1000;
      };

      function elementDrag(e) {
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        elmnt.style.top = `${elmnt.offsetTop - pos2}px`;
        elmnt.style.left = `${elmnt.offsetLeft - pos1}px`;
        isDragging = true;
      }

      function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
        if (isDragging) {
          setTimeout(() => (elmnt.style.zIndex = ''), 100);
          saveToLocalStorage();
        }
        isDragging = false;
      }
    }

    function addNewPage() {
      if (!tasks[activeTaskIndex]) return;
      const newPage = createNewPage(activeTaskIndex, tasks[activeTaskIndex].length);
      tasks[activeTaskIndex].push(newPage);
      updatePageList();
      switchPage(tasks[activeTaskIndex].length - 1);
      saveToLocalStorage();
    }

    function switchPage(index) {
      if (!tasks[activeTaskIndex] || index < 0 || index >= tasks[activeTaskIndex].length) return;
      document.querySelectorAll('.task-pages-container').forEach(c => c.style.display = 'none');
      tasks[activeTaskIndex][index].parentElement.style.display = 'block';
      activePageIndex = index;
      updatePageList();
      saveToLocalStorage();
    }

    function removeCurrentPage() {
      if (!tasks[activeTaskIndex] || tasks[activeTaskIndex].length <= 1) {
        alert('Cannot remove the last page of a task.');
        return;
      }

      tasks[activeTaskIndex].splice(activePageIndex, 1);
      activePageIndex = Math.min(activePageIndex, tasks[activeTaskIndex].length - 1);
      document.getElementById('editor').innerHTML = '';
      tasks[activeTaskIndex].forEach((page, pi) => {
        const container = document.createElement('div');
        container.className = 'task-pages-container';
        if (pi === activePageIndex) container.classList.add('active');
        container.appendChild(page);
        document.getElementById('editor').appendChild(container);
      });
      switchPage(activePageIndex);
      saveToLocalStorage();
    }

    function updatePageList() {
      const pageList = document.getElementById('pageList');
      const pageManagement = document.getElementById('pageManagement');
      pageList.innerHTML = '';
      if (!tasks[activeTaskIndex]) return;
      tasks[activeTaskIndex].forEach((_, index) => {
        const item = document.createElement('div');
        item.className = 'task-item' + (index === activePageIndex ? ' active' : '');
        item.innerText = `Page ${index + 1}`;
        item.onclick = () => switchPage(index);
        pageList.appendChild(item);
      });
      pageManagement.style.display = tasks.length > 0 ? 'block' : 'none';
    }

    function updatePageManagement() {
      const pageManagement = document.getElementById('pageManagement');
      pageManagement.style.display = tasks.length > 0 ? 'block' : 'none';
      updatePageList();
    }





    function downloadPDF() {
      const opt = {
        margin: 0,
        filename: 'document.pdf',
        image: { type: 'jpeg', quality: 1 },
        html2canvas: { scale: 2, useCORS: true },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
      };
      const allPagesContainer = document.createElement('div');
      tasks[activeTaskIndex].forEach(page => {
        const pageClone = page.cloneNode(true);
        pageClone.className = 'task-page';
        allPagesContainer.appendChild(pageClone);
      });
      html2pdf().set(opt).from(allPagesContainer).save();
    }
	
	

  </script>
</body>
</html>
